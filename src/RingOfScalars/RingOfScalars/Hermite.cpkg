-- Author: Florian Walsh
-- This implementation is part of my master thesis. 
-- A detailed package description is contained in the appendix of the thesis.

Package $HermiteNF	

Alias HP := $HelpFunctions;

Define About()
  PrintLn "
    Author : Florian Walsh
    Comment: Contains functions for computing the Hermite normalform and solving linear systems
    over the integers.
  "
EndDefine;

-- Computes a solution of the linear system AX=B. If only one argument A is given then
-- the function computes a basis of the solution space of the homogeneous system AX=0
Define SolveDioph(...)
	If Len(ARGV) = 2 Then
		-- One solution of the system AX=B is returned
		Return $.SolveDiophCore(ARGV[1], ARGV[2], False);
	ElIf Len(ARGV) = 1 Then
		-- A basis of the solution space of AX=0 is returned
		B := NewMat(NumRows(ARGV[1]), 1, 0);
		Return $.SolveDiophCore(ARGV[1], B, True);
	Else
		Error("$HermiteNF.SolveDioph: False number of arguments.");
	EndIf;
EndDefine;

-- Computes the Hermite normalform of the matrix A
Define HermiteNF(A)
	M := NumRows(A);
	N := NumCols(A);
	U := Identity(M);
	For T := 1 To M Do 
		R := 0;
		For S := 1 To N Do
			If A[R+1][S] <> 0 Or A[T][S] <> 0 Then
				R := R+1;
				If T = R Then
					IF A[T][S] < 0 Then
						A[T] := -1 * A[T];
						U[T] := -1 * U[T];
					EndIf;
				Else
					If A[R][S] <> 0 Or A[T][S] <> 0 Then
						$.ColGcd(A, U, S, R, T);
					EndIf;
				EndIf;
				For L := 1 To R-1 Do
					F := HP.Floor(A[L][S], A[R][S]);
					A[L] := A[L] - F * A[R];
					U[L] := U[L] - F * U[R];
				EndFor;
				If T = R Then
					Break;
				EndIf;
			EndIf;
		EndFor;
	EndFor;	
	Return Record[H := A, P := U];
EndDefine;

Define ColGcd(Var A, Var U, S, Z1, Z2)	
		Sol := HP.ExtendedGcd(A[Z1][S], A[Z2][S]);	
		D := Sol[1] * A[Z1][S] + Sol[2] * A[Z2][S];
		AZ1 := A[Z1];
		AZ2 := A[Z2];
		UZ1 := U[Z1];
		UZ2 := U[Z2];
		AZ1S := A[Z1][S];
		AZ2S := A[Z2][S];
		A[Z1] := Sol[1] * AZ1 + Sol[2] * AZ2;
		U[Z1] := Sol[1] * UZ1 + Sol[2] * UZ2;
		A[Z2] := -AZ2S/D * AZ1 + AZ1S/D * AZ2;
		U[Z2] := -AZ2S/D * UZ1 + AZ1S/D * UZ2;
EndDefine;


Define SolveDiophCore(A, B, Hom)
	M := NumRows(A);
	N := NumCols(A);
	C := Transposed(MatConcatHor(-B,A));
	Col := NewMat(N+1, 1, 0);
	Col[1][1] := 1;
	C := MatConcatHor(C, Col);
	Hermite := $.HermiteNF(C);
	PRows := NumRows(Hermite.P);
	PCols := NumCols(Hermite.P);
	I := 1;
	While Hermite.P[I,1] = 0 And I < PRows Do
		I := I + 1;
	EndWhile;
	If Hermite.P[I,1] = 1 Then
		If Hom And I < PRows Then
			Return List(Submat(Hermite.P, (I+1)..PRows, 2..PCols));
		Elif Hom And I = PRows Then
			-- the solution space is generated by one element
			Return [WithoutNth(Hermite.P[I],1)];
		Else
			Return WithoutNth(Hermite.P[I],1);
		EndIf;
	EndIf;
	Return [];
EndDefine;

EndPackage;